Cuando tenemos un pod levantado en kubernetes, este tiene unos mecanismos para saber si dicho pod se encuentra en estado saludable. Para ello, cada pod tiene un endpoint llamado healthcheck dónde devuelve un 200 en caso de ir todo bien.

El problema se produce cuando por el motivo que sea, o bien dicho pod no puede satisfacer una alta demanda de peticiones o tiene que llamar a otro microservicio o servicio externo y este tarda en responder, el tomcat que tiene dicho microservicio llega a su límite de peticiones concurrentes. Por defecto suele venir con una configuración de 200 peticiones concurrentes. Si las 200 están ocupadas y kubernetes llama a su healthcheck, dicha llamada no entra con lo cual tras varios intentos sin respuesta, kubernetes piensa que dicho pod está corrupto y decide reiniciarlo. Eso provoca que todas las peticiones que hay junto a reintentos provocados por balanceadores vuelvan a ir otra vez contra el pod en cuanto se reinicie volviendo a saturar y volviendo a no dejar paso al healtcheck y volviendo a reiniciarse. Suele pasar en entornos de producción que al ralentizarse una base de datos, caigan en cascada varios microservicios por esa causa. También provoca que una vez arreglado el problema de la base de datos sigan sin poder levantar los demás microservicios quedando todos los pods reiniciandose una y otra vez. Esto se debe a qu normalmente hay mecanismos de reintentos en caso de peticiones fallidas y se encolan una gran cantidad de peticiones que no tienen destino hasta que un pod levanta. Una vez levantado van todos a la vez volviendo a saturar el pod sin dejar tiempo a consumir la petición. Esto pasa con todos los pods y la plataforma entra en un bucle difícil de salir. Por ello, es interesante implementar una forma que aunque se llene de peticiones un pod, siempre haya libre un hilo del tomcat para la llamada del healtcheck de kubernetes y así no lo reinicie.

Para ello creamos un filter para contabilizar todas la peticiones que entran y salen creando un contador de peticiones concurrentes. Cuando entra una petición se suma uno al contador y cuando sale se resta. En caso de llegar a n-1 peticiones concurrentes la siguiente petición en vez de dejarla pasar en el filter la rechazamos para dejar 1 hueco a la petición del healtcheck. Solo la dejamos pasar en caso de detectar que sea la petición de healtcheck. Es mejor rechazar peticiones y poder servir las otras que ya han entrado que no dejar hueco a la petición del healtcheck y que se reinicie el pod provocando la perdida de todas las peticiones anteriores.

Ejemplo:

